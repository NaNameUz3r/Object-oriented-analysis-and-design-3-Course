# Задание 6. Отфильтруйте ранее выделенные АТД по следующим правилам, укажите, почему вы отказались от тех или иных классов.

 Основные рекомендации по отбраковке потенциальных АТД:

- кандидат не подходит, если он инкапсулирует некоторое действие, функцию, а не задаёт структуру данных с оригинальным набором операций (что часто бывает при функциональной декомпозиции). 
В частности, кандидат отбраковывается, если для него напрашивается название в форме императивного глагола, или инфинитива, или если это полностью реализованный класс с одним публичным методом (он скорее всего реализовывает некоторую функцию, действие, а не структуру данных).
Правильное название класса -- либо существительное, либо прилагательное, описывающее некоторое свойство, характерное для разных структур данных, с окончанием на -able (например, comparable, sortable, ...);

- кандидат не подходит, если он отвечает на вопрос "этот класс делает ...", если он "выполняет нечто" -- скорее всего, это неподходящая абстракция данных. Класс не должен делать что-то одно важное, все его операции равноправны;

- кандидат чаще всего не подходит, если он продолжает (или начинает) иерархию классов, когда фаза анализа ещё не закончена. Наследование, как отмечалось на предыдущем курсе, в современных проектах на практике вообще редко используется глубже чем на 2-3 уровня (с учётом классов General и Any, возможно, на 5). Иерархию желательно формировать, только когда основные абстракции проекта уже найдены и хотя бы немного формализованы; при этом, конечно, вполне возможны уточнения выявленных абстракций. То есть спешить с классификацией сущностей никогда не стоит.

- кандидат не подходит, если это класс без методов. Он может содержать важную информацию, но не реализует АТД. Возможно, в соответствующей спецификации АТД забыли указать набор операций.
- кандидат не подходит, если это класс без своих полей, или с небольшим их числом, но наследующий атрибуты своих родителей. Вероятно, ошибочно выполнено построение иерархии классов. Скорее всего, возможности этого класса можно корректно делегировать его предкам выше по иерархии.

- кандидат, как правило, не подходит, если не содержит команды, а только запросы. Возможно, это подобие такого устаревшего типа данных, как "структура" (или современный словарь, допускающий обращение к значениям по ключу), который позволяет работать с его полями напрямую. Исключение из такого случая -- это класс, который инкапсулирует некоторую "неизменяемую" внешнюю сущность (базу данных, сетевой драйвер, информация о работе прибора), и она по определению не должна допускать изменений своего состояния. Два других исключения -- это паттерны наподобие фабрики объектов, которые только создают новые объекты, а также льготное наследование с предыдущего курса (когда например класс содержит лишь наборы констант).

- кандидат не подходит, если в нём смешаны две или больше разных абстракций. Так бывает например, когда вместо отношения композиции две сущности искусственно сливаются в одну в форме класса, в результате чего набор операций АТД разрастается до явно различных по семантике операций. Такой класс должен быть разделен на несколько классов, по одному на каждую абстракцию. 


---

Классы анализа из задания 3: 


- Astronaut - класс моделирующий астронавтов на станции.
  "Не понятно" что делает астронавт. Заранее, кажется что он напрашивается на "начинателя" иерархии, но на фазе анализа это выглядит как предварительные домыслы. Определенно, это будет класс с методами,  и достаточным числом полей.

- StationModule - класс, моделирующий модули станции.
  Тоже выглядит ок.
  
- Event - класс, моделирующий псевдослучайные и запланированные (любые) события на станции.
  Тоже выглядит ок.

- Resource - класс, моделирующий тип ресурса.
  Тоже выглядит ок.

- ResourceManager - класс, моделируюий структуру-хранилище ресурсов, и управление ими (потребление\воспроизводство).
  А вот это уже кандидат на отбраковку. Зачем нужен отдельный ресурс-менеджер, если у нас уже есть АТД ресурса? Ресурс, это по сути класс с хранилищем счетчика конкретного ресурса и методами для арифметических операций с ресурсом. Конкретный ресурс вообще может быть всего лишь объектами класса Resource. 

- Clock - класс, моделирующий течение времени на станции.
  Тот самый класс, который у меня кочует между заданиями. Вообще, я не могу его отсеить. Все таки кажется важным реализовать Clock как Singleton. Нам, вроде бы понятно что делает этот класс, но явно не одна какая то его команда является наиважнейшей. Они все важны и нужны. И время должно управляться внутри симулятора понятным образом. 

- Screen - класс, моделирующий терминал-интерфейс симулятора (экран).
  Не представляю как избавиться от этого АТД, ведь у симулятора должен быть какой то пользовательский интерфейс, который должен генерироваться каким то классом(и).

И ещё... Кажется что мне надо добавить SpaceStation класс, который будет моделировать станцию глобально. В разборе дальше поясню почему так решил.

Резюме по отсеиванию классов анализа:

- Astronaut;
- SpaceStation;
- StationModule;
- Event;
- Resource;
- Clock;
- Screen. 


---

В задании 4 я написал много всего, что оказывается вообще не нужно:

TaskQueue (Очередь задач) и EventQueue (Очередь событий): похоже что мне просто нужно реализовать Queue в симуляторе, для использования в логике событий. Зачем я их тут специфицировал как отдельные очереди для заданий и эвентов, не понятно.

GameLog (Журнал игры): Что это и зачем? Какой АТД и специальный тип\структуру данных это реализует? Отсеиваем. Лог можно писать в файл.

Settings (Настройки): Тут тоже какая это специальная структура? Настройки можно харнить в файле.

RandomGenerator (Генератор случайных чисел): снова не понятно что за структуру это реализует и инкапсулирует. Event должне быть богатым АТД, а генераицей эвентов заниматься какой то класс проектирования (фаблика?)

Storage (Классы хранилища компонентов станции):
    StationModuleStorage (Хранилище модулей станции);
    AstronautStorage (Хранилище астронавтов);
    ResourceStorage (Хранилище ресурсов)...
  
  это все обычные массивы\списки, все это не нужно выделять в отдельные классы. Все эти "хранилища" могут быть полями в SpaceStation.

Timer (Единый источник правды о текущем Времени на станции): Опять тут это? В анализе мы определили clock. Timer не нужен и не реализует особую структуру данных. 

ResourceManager (Менеджер ресурсов): не нужен, отсеиваем. Reourse это просто счетчки с набором арифметических операций. Каждый конкретный ресурс - обьект класса. Зачем тут какой то менеджер?

Резюме по заданию 4: 

- queue; 

---

В задании 5 я просто перечислил шаблоны проектирования, но ничего не написал про классы которые я думал реализовать на их базе.

AstronautStateMachine и StationModuleStateMachinе, кажется, что состояния могут быть реализованы часть АТД Astronaut и StationModule, но я почти уверен что это плохая идея. В этих АТД должны определяться команды обработки события, а вот эти сами обработчики должны быть реализованы как отдельные машины состояний, которые обрабатывают эвент и меняют состояния-статусы астронавта\модуля. 

AstronautFactory и StationModuleFactory предоставляют "интерфейс" для создания экземпляров соответствующих классов.

Observer, кажется стоит отсеить. Я не уверен на данный момент что это должно быть выделено в отдельный АТД. Кажется что шаблон Observer должен быть реализован как часть SpaceStation. 

Singleton — нужен. Я считаю что SpaceStation и Clock должны "быть" Singleton'ами. 

Резюме по "отсеиванию" классов проектирования: точнее расписал мысли. Отсеил Observer. Итого:

- AstronautStateMachine;
- StationModuleStateMachine;
- AstronautFactory;
- StationModuleFactory;
- Singleton.
