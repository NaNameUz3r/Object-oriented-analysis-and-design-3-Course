Классы реализации задают универсальные, достаточно простые и фундаментальные (в рамках проекта) структуры данных наподобие связных списков или динамических массивов. 
Особенность в том, что, как правило, их реализация должна быть очень эффективной, что существенно затрудняет кодирование и подразумевает хорошее знание алгоритмов и computer science. 
Ошибка в выборе алгоритма может обойтись весьма дорого.

Но, как правило, классы реализации легко опытным проектировщиком выявляются, и вдобавок, в стандартных библиотеках обычно доступны самые разные универсальные структуры данных, и достаточно лишь немного их переопределить или расширить под конкретные задачки, а очень часто просто взять готовые.

Готовые классы реализации из стандартных библиотек (списки, словари, деревья, ...), которые используются "как есть", без модификации, включать в проектный список АТД и специфицировать, конечно, не нужно.

# Задание 4. Подумайте, потребуются ли вам в проекте специфические структуры данных (например, какие-то особенные способы хранения объектов), поддерживающие и организующие работу с классами анализа, или достаточно будет обойтись возможностями стандартных библиотек. 

---

Мы не рассматриваем конкретную, внутреннюю реализацию классов реализации. Иными словами, "внутри", следующие АТД могут быть реализованны по большей мере или вообще целиком и полностью на типах стандартной библиотеки Python. Но кажется, что мне потребуются следующие "структуры", выделенные в классы реализации (АТД), с прозранчыми интерфейсами (вдруг в дальнейшем потребуется изменить внутренную реализацию со стандарных типов данных, на более эффективные?):

### TaskQueue (Очередь задач):
D игре присутствуют различные задачи, которые астронавты могут выполнять (например, обслуживание модулей, исследование, ремонт и т.д.). Такая очередь задач может использоваться для организации и распределения задач между астронавтами.

### EventQueue (Очередь событий):
Cобытия в симуляторе играют важную роль (например, прибытие новых астронавтов, аварийные ситуации, появление новых ресурсов и т.д.), очередь событий может использоваться для управления порядком и временем возникновения событий в игре.

### GameLog (Журнал игры):
Требуется вести подробную запись о происходящих событиях и действиях в игре (предполагается построить на этом интерфейс пользователя). Эта структура данных может использоваться для хранения и последующего доступа к истории игры.

### Settings (Настройки):
Если в симуляторе будут реализовываться какие то ни было пользовательские настройки, то потребуется отдельная структура данных для хранения и управления этими настройками. 

### RandomGenerator (Генератор случайных чисел):
Обеспечивает генерацию случайных чисел для различных компонентов игры. Будет использоваться для создания случайных событий и решения вероятностных ситуаций. (На данном этапе, самый сложный из перечисленных классов, в плане придумывания предпоалагаемой реализации, в связи с остальными компонентами игры...)

### <SystemElement>Storage (Классы хранилища компонентов станции):
Не зависимо от внутрнней реализции, кажется очевидным, что потербуется реализовать, как минимум, такие хранилища, как:
- StationModuleStorage (Хранилище модулей станции);
- AstronautStorage (Хранилище астронавтов);
- ResourceStorage (Хранилище ресурсов)...

### Timer (Единый источник правды о текущем Времени на станции):
Отвечает за отсчет времени в игре. Обеспечивает функции для управления временем. (Кажется тут я тоже запутался, ведь я выделял Clock как класс анализа... Или это все таки класс реализации?...)

### ResourceManager (Менеджер ресурсов):
Я, ошибочно, выделили в прошлом задании этот класс, как класс анализа. Но похоже, что это, скорее — класс реализации, который представляет собой хранилище информации о доступных ресурсах на станции и обеспечивает методы для управления количеством ресурсов.


